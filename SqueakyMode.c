#pragma config(Motor,  port2,           LDrive,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           RDrive,        tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port4,           DriveServo,    tmotorServoStandard, openLoop)
#pragma config(Motor,  port5,           RotateServo,   tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           ArmServo,      tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int MaxStickPos = 127;
const int DeadZone = 10;             //Deadzone for joysticks

/*
 * task Chassis() //Task for drive-train
{
    *
    *Assigns variables to read joysticks and apply
    *a slope calculation for a ramp-up of acceleration
    *

    int LeftDriveStick = (vexRT[Ch3] * abs(vexRT[Ch3])) / 127;
    int RightDriveStick = (vexRT[Ch2] * abs(vexRT[Ch2])) / 127;

    if(abs(LeftDriveStick) < 5)
    {
    LeftDriveStick = 0;
    }
    else if(abs(LeftDriveStick) > maxStickPos){
    LeftDriveStick = (MaxStickPos * (LeftDriveStick / (abs(LeftDriveStick)))
    }

    if(abs(RightDriveStick) < 5)
    {
    RightDriveStick = 0;
    }
    else if(abs(RightDriveStick) > maxStickPos){
    RightDriveStick = (MaxStickPos * (RightDriveStick / (abs(RightDriveStick)))
    }
    else
    {
    motor[LMotor] = LeftDriveStick * -1;	//Send values to the motors
    motor[RMotor] = RightDriveStick * -1;
    }

}
 */

task Chassis()
{
	//float LeftDriveStick, RightDriveStick;	//Variables for calculating
	while (true)
	{

        float LeftDriveStick = (vexRT[Ch3] * abs(vexRT[Ch3])) / MaxStickPos;	//Slope calculation for smooth speed increase
        float RightDriveStick = (vexRT[Ch2] * abs(vexRT[Ch2])) / MaxStickPos;

        if(abs(LeftDriveStick) < DeadZone)	//To account for joystick misalignment
		{
			LeftDriveStick = 0;
		}
        else if(LeftDriveStick > MaxStickPos)	//Crutches to ensure we don't overpower the motors
        {
            LeftDriveStick = MaxStickPos;
        }
        else if(LeftDriveStick < -MaxStickPos)
        {
            LeftDriveStick = -MaxStickPos;
        }

        if(abs(RightDriveStick) < DeadZone)	//To account for joystick misalignment
		{
			RightDriveStick = 0;
		}
        else if(RightDriveStick > MaxStickPos)
        {
            RightDriveStick = MaxStickPos;
        }
        else if(ightDriveStick < -MaxStickPos)
        {
            RightDriveStick = -MaxStickPos;
        }

        motor[LDrive] = LeftDriveStick;	//Send the values to the motors
        motor[RDrive] = RightDriveStick;
	}
}

const int HomePos = -100;

task SqueakyMode() //Control mode for squeaky
{
    //Servo Positions
	const int MaxPos = 255;         //Full forward position
	const int RevPos = 0;     //Full backwards position
	const int HalfPos = 30;         //Half-way position either way
    const int RevHalfPos = -30;

    //Servo states
    int DriveServoState = 0;
    int ArmServoState = 0;
    int RotateServoState = 0;

    //Joystick values to set servo position
    const int MidControlLimit = 110;      //Max thumbstick range
    

    /*
    * Checks current position of each joystick,
    * first checking if we have exceeded our dead-zone,
    * then if the joystick is in our full power
    * position or half power position,
    * then finally checking if it has returned to our 
    * starting position when the joystick is released.
    */


    while(true)
    {
        //Joystick axis mapping
        int DriveControl = vexRT[Ch2];
        int ArmControl = vexRT[Ch3];
        int RotateControl = vexRT[Ch4];

        //Section for moving Squeaky
        if(abs(DriveControl) < DeadZone)
        {
            DriveServoState = HomePos;
        }
        else if(DriveControl > DeadZone && DriveControl < MidControlLimit)
        {
            DriveServoState = HalfPos;
        }
        else if(DriveControl < -DeadZone && DriveControl > -MidControlLimit)
        {
            DriveServoState = -HalfPos;
        }
        else if(DriveControl >= MidControlLimit)
        {
            DriveServoState = MaxPos;
        }
        else if(DriveControl <= -MidControlLimit)
        {
            DriveServoState = RevPos;
        }

        //Section for moving Squeaky's arm
        if(abs(ArmControl) < DeadZone)
        {
            ArmServoState = HomePos;
        }
        else if(ArmControl > DeadZone && ArmControl < MidControlLimit)
        {
            ArmServoState = HalfPos;
        }
        else if(ArmControl < -DeadZone && ArmControl > -MidControlLimit)
        {
            ArmServoState = -HalfPos;
        }
        else if(ArmControl >= MidControlLimit)
        {
            ArmServoState = MaxPos;
        }
        else if(ArmControl <= -MidControlLimit)
        {
            ArmServoState = RevPos;
        }

        //Section for rotating Squeaky's arm
        if(abs(RotateControl) < DeadZone)
        {
            RotateServoState = HomePos;
        }
        else if(RotateControl > DeadZone && RotateControl < MidControlLimit)
        {
            RotateServoState = HalfPos;
        }
        else if(RotateControl < -DeadZone && RotateControl > -MidControlLimit)
        {
            RotateServoState = -HalfPos;
        }
        else if(RotateControl >= MidControlLimit)
        {
            RotateServoState = MaxPos;
        }
        else if(RotateControl <= -MidControlLimit)
        {
            RotateServoState = RevPos;
        }

        //Sets our servo positions bsed on previous variable assignments
        motor[DriveServo] = DriveServoState;
        motor[ArmServo] = ArmServoState;
        motor[RotateServo] = RotateServoState;
    }
}

const int StartPos = -70;

task main()
{
	startTask(Chassis);
	bool IsSqueakyModeRunning = false;
	while(true)
    {
		if(vexRT[Btn5D] == true && !IsSqueakyModeRunning){
			stopTask(Chassis);
			startTask(SqueakyMode);
			IsSqueakyModeRunning = true;
		}
		else if(vexRT[Btn6D] == true && IsSqueakyModeRunning){
			stopTask(SqueakyMode);
			startTask(Chassis);
			IsSqueakyModeRunning = false;

            motor[DriveServo] = StartPos;
            motor[ArmServo] = StartPos;
            motor[RotateServo] = StartPos;
		}
	}
}